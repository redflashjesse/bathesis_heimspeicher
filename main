# Imports
import math
import random
from datetime import timedelta
import matplotlib.pyplot as plt
import numpy as np
import pandas as pd
import random as rd
import glob
from matplotlib.ticker import AutoLocator
from matplotlib.lines import Line2D
import matplotlib.lines as mlines

# set dpi globally
plt.rcParams['savefig.dpi'] = 500


def main():
    """
    Responsible for running everything sequentially, main has also the option to jump over some calculation and get
    some csv data, by setting values to false or true
    """
    read_original_data = False  # set up if data csv are availabel, which been calculated before or the calculation
    # runs with the basis data
    reduction_through_pv_sale = True  # set up if the calculation runs with co2_reduction_through_pv_sale or not
    only_plot = False # true - readin allready calculated and save datas from pre. runs and plot thoose data,
    # false - runs through all funktions
    plot_without_bars = True # switsh off bar in all plots
    simulate_new_sizes = True # if there are new setups at the sizes of batteries
    print(f'{simulate_new_sizes=}')
    speichergroessen = [12_000]
                            # list(range(500,  # start
                            #      10_000 + 1,  # end
                            #      500))  # step  # in Wh
    soc_start = None # input as float between 0.1,0,9; default = 0.45

    print(f"--- Read in Smartmeter Daten ---")
    base_data = read_pv_netz_combined()
    base_data.to_csv(f'documents/base_data.csv')
    print(base_data)
    print(len(base_data))

    for size in speichergroessen:
        print(f"--- Simulation Batterie nach Eigenverbrauch mit {size} Wh---")
        batterypower_df = cal_battery_own_consumption(netz_pv=base_data,
                                      soc_start=soc_start,
                                      speichergroesse=size)


def selection_days():
    """
        Auswahl bestimmter Tag aus dem Jahresdatensatz, Auswahl erste Möglichkeit einzelne Tage auszuwählen
        zum Beisspiel zwei Tage im Monat, Daten für die NetzLeistung und PVleistung werden in
        geleichen Tagen ausgeswählt
         :rtype: object
         :param: Name of the file that serves as input. Format : .csv
         :return: list of filename
        """
    list_of_days = []
    days_of_month = 2
    numbers_of_month = list(1,
                            12)
    for numbers_of_month in enumerate(days_of_month):
        day = random.randrange(1,30)
        filename_pv = "data/PV-Anlage/Smartmeter_für_2021/"
        filename_netz = "data/Netzanschluss/Smartdaten_für_2021/"



def read_modbus_pv(filename):
    """
    Daten aus dem Ordner PV-Anlage an df übergeben und den Timestamp als Index setzen.
    Die relevanten Daten (Active power +&-) werden an ein df übergeben, übrige Daten werden nicht weiter berücksichtigt.
    :rtype: object
    :param filename: Name of the file that serves as input. Format : .csv
    :return: Dataframe
    """
# TODO einlesen der Leistungswerte, die Umrechnung auf eine Wh ist noch nicht erfolgt, jeden Wert mit 1/60 multiplizieren
    df = pd.read_csv(f'{filename}', header=1, sep=';')  # read in
    df = df.iloc[1:]  # delete caption
    df = df.reset_index(drop=True)  # index starts with 0
    # transforming unix timestamp to Pandas Timestamp
    df['Timestamp'] = pd.to_datetime(df['UNIX-Timestamp'], unit='s',
                                     origin='unix').round('min') + timedelta(hours=1)
    # select only 'Timestamp', 'Active power+ PV', 'Active power- PV'
    df = df[['Timestamp', 'Active power+', 'Active power-']]
    # set timestamp as index
    df.set_index('Timestamp', inplace=True)
    # rename columns PV
    df.columns = ['PowerGeneratedPV', 'PowerOutputPV']
    # set the format form str to float
    df['PowerGeneratedPV'] = 1/60 * df['PowerGeneratedPV'].astype(float) # set the unit Wh instead of Wmin
    df['PowerOutputPV'] = 1/60 * df['PowerOutputPV'].astype(float)   # set the unit Wh instead of Wmin
    return df


def read_modbus_netz(filename):
    """
    Daten aus dem Ordner Netzanschluss an df übergeben und Timestamp als Index einführen.
    Die Spalten Active power +&- werden unter neuer Bezeichnung zurückgeben.
      :rtype: object
      :param filename: Name of the file that serves as input. Format : .csv
      :return: Dataframe
      """
    # TODO einlesen der Leistungswerte, die Umrechnung auf eine Wh ist noch nicht erfolgt, jeden Wert mit 1/60 multiplizieren
    df = pd.read_csv(f'{filename}',
                     header=1,
                     sep=';')  # read in
    df = df.iloc[1:]  # delete caption
    df = df.reset_index(drop=True)  # index starts with 0
    # unix timestamp to Pandas Timestamp
    df['Timestamp'] = pd.to_datetime(df['UNIX-Timestamp'], unit='s',
                                     origin='unix').round('min') + timedelta(hours=1)

    df = df[['Timestamp', 'Active power+', 'Active power-']]
    # select only 'Timestamp', 'Active power+ PV', 'Active power- PV'
    df.set_index('Timestamp', inplace=True)  # set timestamp as index
    # rename colums
    df.columns = ['GridPowerIn', 'GridPowerOut']  # GridPowerIn = Netzbezug; GriPowerOut = Überschussstrom
    # set the format form str to float
    df['GridPowerIn'] = 1/60 * df['GridPowerIn'].astype(float)  # set the unit Wh instead of Wmin
    df['GridPowerOut'] = 1/60 * df['GridPowerOut'].astype(float)  # set the unit Wh instead of Wmin
    return df

def readall_pv():
    """
    Daten aus dem Ordner PV-Anlage sollen eingebunden werden.
    Die einzeln df werden miteinander verbunden.
    Es sind zwei Smartmeter für das Quatier verbaut,
    sie werden hier zu einem Wert addiert und als df wieder ausgegeben.
     :rtype: object
     :param: Name of the file that serves as input. Format : .csv
     :return: Dataframe
    """
    # getting csv files from the folder PV_Anlage
    path1 = "data/PV-Anlage/Smartdaten_für_2021/Smart1/"
    path2 = "data/PV-Anlage/Smartdaten_für_2021/Smart2/"
    # path1 = "data/PV-Anlage/April/Smart1/"
    # path2 = "data/PV-Anlage/April/Smart2/"

    # read all the files with extension .csv
    filenames1 = glob.glob(path1 + "*4.csv")
    filenames2 = glob.glob(path2 + "*4.csv")
    'data/PV-Anlage/Smart1/SN73144693-EM-PV-OW-2021-04-01.csv'
    # for loop to iterate each folder and concat to one df for a folder

    dfone = pd.DataFrame
    dftwo = pd.DataFrame

    for index, file in enumerate(filenames1):
        df = read_modbus_pv(f'{file}')
        if index == 0:
            dfone = df
        else:
            dfone = pd.concat([dfone, df])

    for index, file in enumerate(filenames2):
        df = read_modbus_pv(f'{file}')
        if index == 0:
            dftwo = df
        else:
            dftwo = pd.concat([dftwo, df])
    # sort by timestamp as index
    # dfone = dfone.sort_values(dfone, by='Timestamp')
    # dftwo = dftwo.sort_values(dftwo, by='Timestamp')
    # combine both smartmeter to one dataframe

    assert not dfone.empty
    assert not dftwo.empty

    df_add = dfone.add(dftwo, fill_value=0)
    return df_add


def readall_netz():
    """
   Daten aus dem Ordner Netzanschluss werden in eine Liste geschrieben,
   welche die Namen der CSV-Dateien beinhaltet. Die einzeln Dateien werden eingelesen und
   miteinander verkünpft. Hier werden die zwei Smartzähler des Quatieres zu einem Wert addiert.
   Das bildet die Grundlage für die Berechnungen.
   :rtype: object
      :param: Name of the file that serves as input. Format : .csv
      :return: Dataframe
      """
    # getting csv files from the folder Netzanschluss
    path1 = "data/Netzanschluss/Smartdaten_für_2021/Smart1/"
    path2 = "data/Netzanschluss/Smartdaten_für_2021/Smart2/"
    # path1 = "data/Netzanschluss/April/Smart1/"
    # path2 = "data/Netzanschluss/April/Smart2/"
    # todo Netz/smart1 Datei vom 2021-03-29 hat einen Fehler bei der formatierung des Unix Timestamp

    # read all the files with extension .csv
    filenames1 = glob.glob(path1 + "*4.csv")
    filenames2 = glob.glob(path2 + "*4.csv")

    # for loop to iterate each folder and concat to one df for a folder
    dfone = pd.DataFrame
    dftwo = pd.DataFrame

    for index, file in enumerate(filenames1):
        df = read_modbus_netz(f'{file}')
        if index == 0:
            dfone = df
        else:
            dfone = pd.concat([dfone, df])

    for index, file in enumerate(filenames2):
        df = read_modbus_netz(f'{file}')
        if index == 0:
            dftwo = df
        else:
            dftwo = pd.concat([dftwo, df])

    # sort by timestamp as index
    dfone = dfone.sort_values(by='Timestamp')
    dftwo = dftwo.sort_values(by='Timestamp')

    # combine both smartmeter to one dataframe
    df_add = dfone.add(dftwo, fill_value=0)
    return df_add


def read_pv_netz_combined():
    """
    Ruft die pv und netz Funktionen auf und schreibt die in ein df.
         :return: Dataframe
         """
    pv_df = readall_pv()
    netz_df = readall_netz()
    # df = pd.concat([pv_df, netz_df], axis=1) # Todo
    print(pv_df.head())
    print(len(pv_df))
    print(netz_df.head())
    print(len(netz_df))
    df = pv_df.merge(netz_df, left_on='Timestamp', right_on='Timestamp', how='outer')
    df.fillna(0.0)
    df = df.iloc[:-2:]
    print(df.head())
    print(len(df))

    return df

def cal_pv_eigennutzung(netz_pv):
    """
   Innerhalb dieser Funktion werden die Emission berechnet,
   die durch den selbstgenutzten Strom der Photovoltaik entstehen.

      :param: Name of the file that serves as input. Format : .csv
      :return: Dataframe
      """

    eigenverbrauch = []
    for _, row in netz_pv.iterrows():
        # convert W to kW
        internally_used_power = float(row.PowerGeneratedPV - row.GridPowerOut) / 1000
        eigenverbrauch.append(internally_used_power)
    netz_pv['PV-Eigennutzung'] = eigenverbrauch
    return netz_pv

def cal_battery_own_consumption(netz_pv, speichergroesse, soc_start=None):
        """
        Rechnung um den Speicher zu simulieren, die Leistungswerte und den neuen
        State of Charge in einer Liste wiederzugeben. Je nach Varianten kann so eine mögliche Leistung aufgezeigt werden.
        Parameter und Daten zu einem Speicher sind hier hinterlegt. Dieser kann durch die Speichergroesse angepasst werden.
        Dies ist die Grundlage für eine Berechnung der möglichen Emissionen, bei gleicher Leistung.

         :rtype: Dataframe
         :param: Dataframe
         :return: Dataframe
         """

        eta = 0.9  # Efficiency factor
        soc_max = 0.9  # [range: 0-1 ]
        soc_min = 0.1  # [range: 0-1 ]
        zeit = 60  # [minute]

        p_ges = speichergroesse / zeit  # [W] / [minute]
        c_out = 1  # Coulombe Factor, depends on battery rating
        c_in = 0.5  # Coulombe factor
        min_flow_threshold = 0.1  # threshold for minimal flow for action to be taken [range: 0-1] in %

        p_max_out = p_ges * c_out
        p_min_out = p_max_out * min_flow_threshold
        p_max_in = p_ges * c_in
        p_min_in = p_max_in * min_flow_threshold

        # Efficiency included in the borderline cases, set new limits
        p_max_out *= eta
        p_min_out *= eta
        p_max_in = p_max_in * (1 + (1 - eta))
        p_min_in = p_min_in * (1 + (1 - eta))

        soc = []  # minute-wise soc
        p_delta = []  # the difference in power per minute
        soc_deltas = [] # the difference in state of charge
        netzbezug = [] # result amuont of power form the grid
        netzeinspeisung = []  # result amuont of power to the grid
        netzleistung = [] # grid power
        p_netzeinspeisung = 0

        if soc_start:
            soc_akt = soc_start  # This represents an opportunity to specify a defined state of charge.
        else:
            soc_akt = soc_max / 2  # assumption: 45% charged at startup

        for index, row in netz_pv.iterrows():
            # Default: no change, no in, no out, p_soll = 0
            soc_ist = soc_akt
            soc_delta = 0
            p_ist = 0
            # Show network interface whether import or withdrawal takes place
            p_soll = float(row['GridPowerIn']) - float(row['GridPowerOut'])

            if p_soll > 0:  # check for positive
                # p_supply = p_soll * (1 + (1 - eta))  # factor in losses
                p_ist = min(p_max_out, p_soll)  # Threshold for upper bound

                if p_ist >= p_min_out:  # Threshold for lower bound
                    soc_delta = ((p_ist * (1 + (1 - eta))) / (speichergroesse / 100)) / 100
                    soc_akt = soc_ist - soc_delta

                # Capacity check, prevent depletion
                if soc_akt < soc_min:
                    soc_akt = soc_ist
                    p_ist = 0
                    soc_delta = 0

            if p_soll < 0:  # Query whether storage can be carried out with excess current # case p_soll negative
                p_supply = abs(p_soll)
                p_ist = min(p_max_in, p_supply)

                if p_ist >= p_min_in:
                    p_ist = -p_ist  # invert value to reflect incoming p
                    soc_delta = ((p_ist * eta) / (speichergroesse / 100)) / 100
                    soc_akt = soc_ist - soc_delta

                # Capacity check, prevent overcharge
                if soc_akt > soc_max:
                    soc_akt = soc_ist
                    p_ist = 0
                    soc_delta = 0

            # calculation of the grid power by intergration of a battery
            if p_ist > 0:
                p_netzbezug = row['GridPowerIn'] - max(p_ist, 0)
            if p_ist < 0:
                p_netzeinspeisung = row['GridPowerOut'] + min(p_ist,0)
            if p_ist==0:
                p_netzbezug = row['GridPowerIn']
                p_netzeinspeisung = row['GridPowerOut']

            p_netz = p_netzbezug - p_netzeinspeisung

            soc.append(soc_ist)
            p_delta.append(p_ist)
            soc_deltas.append(soc_delta)
            netzbezug.append(p_netzbezug)
            netzeinspeisung.append(p_netzeinspeisung)
            netzleistung.append(p_netz)

        netz_pv[f'p_delta_{speichergroesse}Wh_eigenverbrauch'] = p_delta
        netz_pv[f'current_soc_{speichergroesse}Wh_eigenverbrauch'] = soc
        netz_pv[f'soc_delta_{speichergroesse}Wh_eigenverbrauch'] = soc_deltas
        netz_pv[f'p_netzbezug_{speichergroesse}Wh_eigenverbrauch'] = netzbezug
        netz_pv[f'p_netzeinspeisung_{speichergroesse}Wh_eigenverbrauch'] = netzeinspeisung
        print(f'--- Save Netz PV Speicher Eigenverbrauch als csv ---')
        netz_pv.to_csv(f'documents/netz_pv_mit_speichersimulation_eigenverbrauch.csv')
        return netz_pv # Leistungen_Speicher_eigenverbrauch


def plot_power_one_day():

    return


# Makes the method main
# __name__
if __name__ == "__main__":
    main()